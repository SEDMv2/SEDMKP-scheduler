#!/usr/bin/env python

import os, sys
import optparse
import requests
import urllib
from astropy.time import Time, TimeDelta
import astropy.units as u
import pandas as pd
import glob
import logging

from io import StringIO


def parse_commandline():
    """
    Parse the options given on the command-line.
    """
    parser = optparse.OptionParser()
    parser.add_option("-w", "--host", default="https://fritz.science",
                      help="Host url for skyportal instance, by default fritz")
    parser.add_option("-p", "--queuePath", default="/home/sedm/Queue/sedmv2", help="Default path where queue scripts are")
    parser.add_option("-f", "--outfile", default="queue_target.dat", help="Output file name")
#     parser.add_option("-o", "--outputDir", default="./", help="Output directory path")
#     parser.add_option("-r", "--requests", default="/home/sedm/Queue/sedmv2/requests/",
#                       help="Requests folder path where top request from scheduler is sent")
    parser.add_option("-t", "--token", help="Fritz/skyportal token, required")
    parser.add_option("--doPlots", action="store_true", default=False, help="Make plots")
    parser.add_option("--doTime", action="store_true", default=False, help="Not implemented yet")

    opts, args = parser.parse_args()

    return opts

opts = parse_commandline()

logging.basicConfig(filename=f'{opts.queuePath}/scheduler_{Time.now().strftime("%Y%m%d")}.log', encoding='utf-8', level=logging.DEBUG,
                    format='%(asctime)s %(message)s')
logging.getLogger("urllib3").setLevel(logging.CRITICAL)
# Parse command line
outfile = f'{opts.queuePath}/{opts.outfile}'

# outputDir = opts.outputDir
# if not os.path.isdir(outputDir):
#     os.makedirs(outputDir)

if opts.doTime:
    tstart = Time(opts.tstart)
    tend = Time(opts.tend)
else:
    tstart = Time.now()
    tend = Time.now() + TimeDelta(12 * u.hour)

if opts.token:
    headers = {'Authorization': f'token {opts.token}'}
elif len(glob.glob(f'{opts.queuePath}/token.txt'))!=0:
    token = open(f'{opts.queuePath}/token.txt', 'r').read().strip()
    headers = {'Authorization': f'token {token}'}
else:
    headers = None
    logging.error('get_obs: Token not found, cannot access queue')
    sys.exit(1)

method = 'GET'
start_date = Time.now()
end_date = Time.now() + TimeDelta(12 * u.hour)

session = requests.Session()

endpoint = 'instrument'
url = urllib.parse.urljoin(opts.host, f'/api/{endpoint}')
response = session.request(method, url, headers=headers)

for instrument in response.json()["data"]:
    if instrument["name"] == "SEDMv2":
        instrument_id = instrument["id"]
        break
logging.info(f'get_obs: Found instrument id {instrument_id}')

endpoint = f'followup_request/schedule/{instrument_id}'
url = urllib.parse.urljoin(opts.host, f'/api/{endpoint}')
params = {'observationStartDate': str(Time.now() + TimeDelta(12 * u.hour)),
          'observationEndDate': str(Time.now() + TimeDelta(24 * u.hour)),
          'status': 'submitted',
          'output_format': 'csv'}

logging.info('get_obs: Making request now')
response = session.request(method, url, params=params, headers=headers)

output_string = response.content.decode('utf-8')
output = StringIO(output_string)
logging.info(output_string)
if 'error' in output_string:
    if 'Need at least one observation to schedule' in output_string:
        logging.error('get_obs: No observations scheduled... sorry.')
        sys.exit(2)
    else:
        logging.error('get_obs: Could not access queue')
        sys.exit(1)

df = pd.read_csv(output)

if len(df) == 0:
    logging.error('get_obs: No observations scheduled... sorry.')
    sys.exit(2)

row = df.iloc[0]
required_columns = ["requester", "group_id", "object_id", "request_id", "ra", "dec", "epoch", "exposure_time", "filter"]
for col in required_columns:
    if col not in df.columns:
        logging.error(f'get_obs: {col} not present in queue request')
        sys.exit(5)
filternames = {'u':'FILTER_SLOAN_U', 'g':'FILTER_SLOAN_G', 'r':'FILTER_SLOAN_R', 'i':'FILTER_SLOAN_I', 'z':'FILTER_SLOAN_Z',
              'IFU':'FILTER_IFU'}
filt = filternames[row["filter"]]

fid = open(outfile, 'w')
now = Time.now()
gps = now.gps
requestID = "%s_%d" % (row["object_id"], gps)
mag = 99
mode = 0
ra_rate = 0
dec_rate = 0
print('PROGRAM_PI=%s' % row["requester"], file=fid, flush=True)
print('PROGRAM_ID=%s' % row["group_id"], file=fid, flush=True)
print('OBJECT_ID=%s' % row["object_id"], file=fid, flush=True)
print('REQUEST_ID=%s' % row["request_id"], file=fid, flush=True)
print('COMMENT=%s' % requestID, file=fid, flush=True)
print('OBJ_RA=%s' % row["ra"], file=fid, flush=True)
print('OBJ_DEC=%s' % row["dec"], file=fid, flush=True)
print('EQUINOX=%.2f' % row["epoch"], file=fid, flush=True)
print('RA_RATE=%.2f' % ra_rate, file=fid, flush=True)
print('DEC_RATE=%.2f' % dec_rate, file=fid, flush=True)
print('MAGNITUDE=%.2f' % mag, file=fid, flush=True)
print('EXPTIME=%d' % row["exposure_time"], file=fid, flush=True)
print('FILTER=%s' % filt, file=fid, flush=True)
print('CAMERA_MODE=%d' % mode, file=fid, flush=True)
fid.close()

# Checking if the saved queue_target.dat has the correct request_id
if open(outfile, 'r').readlines()[3].split('=')[-1].strip() != str(row["request_id"]):
    logging.error('get_obs: Error in saving queue_target.dat')
    sys.exit(6)

#cp_command = "cp %s %s/%s.dat" % (outfile, opts.requests, requestID)
#os.system(cp_command)
sys.exit(0)
